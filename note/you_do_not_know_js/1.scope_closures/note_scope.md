# 作用域和闭包

## 作用域是什么
---

### 1. 编译原理

js是一门编译语言；
和传统的编译语言不同，它不是提前编译的；
大部分情况下编译发生在代码执行前的几微秒的时间内。

#### 一般的编译流程：
* 分词/词法分析：将字符串分解成有意义的代码块（词法单元）
* 解析/语法分析：将词法单元转化成AST
* 代码生成：将AST转换成可执行代码

### 2. 理解作用域
* 引擎：从头至尾负责整个JS程序的编译和执行过程
* 编译器：负责语法分析及代码生成
* 作用域：负责收集并维护由所有声明的变量组成的一系列查询，并实施一套严格的规则，确定当前执行的代码对这些变量的访问权限

```js
// 以一个赋值语句为例:
var a = 2;
// 首先编译器会在当前作用域中声明一个变量（如果之前没有声明过）,然后在运行时引擎会在作用域中查找该变量，如果能找到就会对它赋值
```

引擎在作用域中查询变量的方式：

* LHS查询
* RHS查询

## 词法作用域
---

### 1. 词法阶段

* 词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的。
* 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

### 2. 欺骗词法

* eval
* with

## 函数作用域和块作用域
---

### 1.函数作用域
* 具名函数
* 匿名函数
* 立即执行函数表达式

### 2.块作用域
* with
* try/catch: catch分句会创建一个块作用域
* let
  * let关键字可以将变量绑定到所在的任意作用域中（通常是{ ... }内部）
  * 使用let进行的声明不会在块作用域中进行提升
* const

#### 为let声明显示的创建作用域块，可以让引擎清楚的知道没有必要保存快内的变量，方便内存回收
```js
var foo = 2
if (foo) {
  { // 显示的块
    let bar = foo * 2
    bar = something(bar)
    console.log(bar)
  }
} 
console.log(bar) // ReferenceError
```

## 提升
---
引擎会在解释js代码之前首先对其进行编译。编译阶段的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。因此，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。

```js
var a = 2;
// 这看似是一个声明，Javascript实际上会将其看成两个声明：
var a;
a = 2;
// 第一个定义声明是在编译阶段进行的
// 第二个赋值声明会被留在原地等待执行阶段
```
* 只由声明本身会被提升，赋值或其他运行逻辑留在原地
* 函数声明会被提升，但函数表达式不会被提升
* 函数优先，函数会首先被提升，然后才是变量

## 作用域闭包
---



































